«REM»
Copyright 2018 Gregorio Perego, Stefania Pezzetti, Aldo Pintus, Alessio Rossotti, Massimo Beccari
This file is part of it.polimi.mobilecodegenerator.

it.polimi.mobilecodegenerator is free software: 
you can redistribute it and/or modify it under the terms of the 
GNU General Public License as published by the Free Software Foundation, 
either version 3 of the License, or (at your option) any later version.

it.polimi.mobilecodegenerator is distributed in the hope that it will be useful, 
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  
See the GNU General Public License for more details.You should have received a copy of the GNU General Public License
along with it.polimi.mobilecodegenerator. If not, see <http://www.gnu.org/licenses/>
«ENDREM»

«EXTENSION app_extensions::Java»

«IMPORT metamodel»
«DEFINE main FOR Application-»
«IF menu != null && menu.menuItems.size > 0-»
«EXPAND menuViewController FOR this-»
«ENDIF-»
«EXPAND viewController FOREACH viewControllers-»
«EXPAND parentViewController FOREACH scenes-»
«ENDDEFINE-»

«REM» Model's Scenes are translated into ViewControllers in folder ParentViewControllers «ENDREM»
«DEFINE parentViewController FOR Scene-»
«FILE application.name +"/"+application.name +"/ParentViewControllers/"+ name.toFirstUpper()+"ParentViewController.swift"-»
//
//  «name.toFirstUpper()»ParentViewController.swift
//  «name.toFirstUpper()»
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «application.companyIdentifier.split(".").last()». All rights reserved.
//

import UIKit

class «name.toFirstUpper()»ParentViewController: UIViewController {
    
    // MARK: Properties
    «FOREACH sceneViewControllers AS svc-»
	fileprivate let «svc.viewController.name.toFirstLower()»VC: UIViewController
	«ENDFOREACH-»
	«IF !typeSmartphone.toString().matches(typeTablet.toString())-»
    fileprivate var layoutType: Int = Constants.SCENE_TYPE_SINGLE_VC
    «ENDIF-»
    «IF isAMenuDestination(name, application.menu.menuItems.navigation.destinationScene.name)-»
    lazy var menuTransitioningDelegate = MenuPresentationManager()
    «ENDIF-»
    
    «IF typeSmartphone.toString().matches("singleVCTab") || typeTablet.toString().matches("singleVCTab")-»
    fileprivate var tabBar: UITabBar? = nil
    «ENDIF-»
    
    // MARK: Initialization
    init() {
        let storyboard = UIStoryboard(name: "Main", bundle: nil)
        «FOREACH sceneViewControllers AS svc-»
		«svc.viewController.name.toFirstLower()»VC = storyboard.instantiateViewController(withIdentifier: "«svc.viewController.name.toFirstUpper()»ViewControllerStoryboardID")
		«ENDFOREACH-»
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder aDecoder: NSCoder) {
        let storyboard = UIStoryboard(name: "Main", bundle: nil)
        «FOREACH sceneViewControllers AS svc-»
		«svc.viewController.name.toFirstLower()»VC = storyboard.instantiateViewController(withIdentifier: "«svc.viewController.name.toFirstUpper()»ViewControllerStoryboardID")
		«ENDFOREACH-»
        super.init(coder: aDecoder)
    }
    
    // MARK: UIViewController
    override func viewDidLoad() {
        super.viewDidLoad()
        
        «IF isAMenuDestination(name, application.menu.menuItems.navigation.destinationScene.name)-»
	    let menuIcon = UIImage(named: "menu_icon")
	    navigationItem.leftBarButtonItem = UIBarButtonItem(image: menuIcon, style: .plain, target: self, action: #selector(showMenu))
	    «ENDIF-»	
        
        «IF typeSmartphone.toString().matches(typeTablet.toString())-»
        setupUI()
        «ELSE-»
        if UIDevice.current.userInterfaceIdiom == .phone {
        	«IF typeSmartphone.toString().matches("singleVC")-»
        	layoutType = Constants.SCENE_TYPE_SINGLE_VC
        	«ELSEIF typeSmartphone.toString().matches("singleVCTab")-»
        	layoutType = Constants.SCENE_TYPE_SINGLE_VC_TAB
        	«ELSE-»
        	layoutType = Constants.SCENE_TYPE_MULTI_VC
        	«ENDIF-»
            setupPhoneUI()
        } else if UIDevice.current.userInterfaceIdiom == .pad {
        	«IF typeTablet.toString().matches("singleVC")-»
        	layoutType = Constants.SCENE_TYPE_SINGLE_VC
        	«ELSEIF typeTablet.toString().matches("singleVCTab")-»
        	layoutType = Constants.SCENE_TYPE_SINGLE_VC_TAB
        	«ELSE-»
        	layoutType = Constants.SCENE_TYPE_MULTI_VC
        	«ENDIF-»
            setupTabletUI()
        }
        «ENDIF-»
    }

    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
    
    «IF isAMenuDestination(name, application.menu.menuItems.navigation.destinationScene.name)-»
    func showMenu() {
    	let storyboard = UIStoryboard(name: "Main", bundle: nil)
		let menuViewController = storyboard.instantiateViewController(withIdentifier: "MenuViewControllerStoryboardID") as! MenuViewController
		menuViewController.delegate = self
		menuViewController.transitioningDelegate = menuTransitioningDelegate
		menuViewController.modalPresentationStyle = .custom
		present(menuViewController, animated: true, completion: nil)
	}
    «ENDIF-»
    
    «IF typeSmartphone.toString().matches(typeTablet.toString()) && !typeSmartphone.toString().matches("multiVC")-»
    // MARK: UI Setup
    private func setupUI() {
    	«EXPAND setupUIAddChildViewControllers FOR this-»
        «IF typeSmartphone.toString().matches("singleVCTab")-»
		«EXPAND setupUIsingleVCTabConstraints FOR this-»
    	«ENDIF-»
    	show«sceneViewControllers.first().viewController.name.toFirstUpper()»VC()
    }
    «ELSE-»
    // MARK: Phone UI Setup
    private func setupPhoneUI() {
        «IF typeSmartphone.toString().matches("singleVC") || typeSmartphone.toString().matches("singleVCTab")-»
    	«EXPAND setupUIAddChildViewControllers FOR this-»
        «IF typeSmartphone.toString().matches("singleVCTab")-»
		«EXPAND setupUIsingleVCTabConstraints FOR this-»
    	«ENDIF-»
    	show«sceneViewControllers.first().viewController.name.toFirstUpper()»VC()
    	«ELSE-»
    	«EXPAND setupUImultiVC FOR parentViewControllers.first()-»
    	«ENDIF-»
    }
    
    // MARK: Tablet UI Setup
    private func setupTabletUI() {
        «IF typeTablet.toString().matches("singleVC") || typeTablet.toString().matches("singleVCTab")-»
    	«EXPAND setupUIAddChildViewControllers FOR this-»
        «IF typeTablet.toString().matches("singleVCTab")-»
		«EXPAND setupUIsingleVCTabConstraints FOR this-»
    	«ENDIF-»
    	show«sceneViewControllers.first().viewController.name.toFirstUpper()»VC()
    	«ELSE-»
    	«EXPAND setupUImultiVC FOR parentViewControllers.last()-»
    	«ENDIF-»
    }
    «ENDIF-»
    
    «IF !typeSmartphone.toString().matches("multiVC") || !typeTablet.toString().matches("multiVC")-»
    // MARK: functions that show each child view controller for singleVC/singleVCTab type scenes
    «FOREACH sceneViewControllers AS svc-»
	fileprivate func show«svc.viewController.name.toFirstUpper()»VC() {
		«IF typeSmartphone.toString().matches("singleVCTab") || typeTablet.toString().matches("singleVCTab")-»
		for v in view.subviews {
			if v as? UITabBar == nil {
				v.removeFromSuperview()
			}
		}
		«ELSE-»
		if view.subviews.count > 0 {
			view.subviews[0].removeFromSuperview()
		}
		«ENDIF-»
	
		let «svc.viewController.name.toFirstLower()»View = «svc.viewController.name.toFirstLower()»VC.view!
        view.addSubview(«svc.viewController.name.toFirstLower()»View)
            
        «IF (typeSmartphone.toString().matches("singleVC") && typeTablet.toString().matches("singleVCTab")) || (typeSmartphone.toString().matches("singleVCTab") && typeTablet.toString().matches("singleVC"))-»
		NSLayoutConstraint.activate([
	            «svc.viewController.name.toFirstLower()»View.leadingAnchor.constraint(equalTo: view.leadingAnchor),
	            «svc.viewController.name.toFirstLower()»View.trailingAnchor.constraint(equalTo: view.trailingAnchor),
	            «svc.viewController.name.toFirstLower()»View.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor)
            	])
		if layoutType == Constants.SCENE_TYPE_SINGLE_VC {
			NSLayoutConstraint.activate([«svc.viewController.name.toFirstLower()»View.bottomAnchor.constraint(equalTo: view.bottomAnchor)])
		} else {
			NSLayoutConstraint.activate([«svc.viewController.name.toFirstLower()»View.bottomAnchor.constraint(equalTo: tabBar!.topAnchor)])
		}
		«ELSEIF typeSmartphone.toString().matches("singleVC") || typeTablet.toString().matches("singleVC")-»
		NSLayoutConstraint.activate([
	            «svc.viewController.name.toFirstLower()»View.bottomAnchor.constraint(equalTo: view.bottomAnchor),
	            «svc.viewController.name.toFirstLower()»View.leadingAnchor.constraint(equalTo: view.leadingAnchor),
	            «svc.viewController.name.toFirstLower()»View.trailingAnchor.constraint(equalTo: view.trailingAnchor),
	            «svc.viewController.name.toFirstLower()»View.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor)
            	])
		«ELSE-»
		NSLayoutConstraint.activate([
	            «svc.viewController.name.toFirstLower()»View.bottomAnchor.constraint(equalTo: tabBar!.topAnchor),
	            «svc.viewController.name.toFirstLower()»View.leadingAnchor.constraint(equalTo: view.leadingAnchor),
	            «svc.viewController.name.toFirstLower()»View.trailingAnchor.constraint(equalTo: view.trailingAnchor),
	            «svc.viewController.name.toFirstLower()»View.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor)
            	])
		«ENDIF-»
	}
	«ENDFOREACH-»
    «ENDIF-»
    
}

«IF isAMenuDestination(name, application.menu.menuItems.navigation.destinationScene.name)-»
// MARK: MenuViewControllerDelegate
extension «name.toFirstUpper()»ParentViewController: MenuViewControllerDelegate {
	func menuViewController(controller: MenuViewController, didSelectItem selectedItem: MenuItem) {
		var selectedViewController: UIViewController?
		switch selectedItem.destinationID {
		«FOREACH application.menu.menuItems AS mi-»
    	case "«mi.navigation.destinationScene.name.toFirstUpper()»":
    		selectedViewController = «mi.navigation.destinationScene.name.toFirstUpper()»ParentViewController()
    	«ENDFOREACH-»
    	default:
    		break
		}
		// Dismiss MenuViewController
		dismiss(animated: true)
		if selectedViewController != nil {
			navigationController!.viewControllers.append(selectedViewController!)
			navigationController!.viewControllers.removeFirst()
		}
	}
}
«ENDIF-»

«IF typeSmartphone.toString().matches("singleVCTab") || typeTablet.toString().matches("singleVCTab")-»
// MARK: UITabBarDelegate
extension «name.toFirstUpper()»ParentViewController: UITabBarDelegate {
    func tabBar(_ tabBar: UITabBar, didSelect item: UITabBarItem) {
    	switch item.tag {
    	«FOREACH 0.upTo(sceneViewControllers.size - 1) AS i-»
    	case «i»:
    		show«sceneViewControllers.get(i).viewController.name.toFirstUpper()»VC()
    	«ENDFOREACH-»
    	default:
    		break
    	}
    }
}
«ENDIF-»

«IF containsControlsWithNavigation(sceneViewControllers.viewController.buttons, sceneViewControllers.viewController.listViews, sceneViewControllers.viewController.gridViews)-»
// MARK: ChildViewControllerInteractionProtocol
extension «name.toFirstUpper()»ParentViewController: ChildViewControllerInteractionProtocol {

	func childViewControllerInteraction(controlId: String, selectedItem: Any?) {
		switch controlId {
    	«FOREACH sceneViewControllers AS svc-»
		«REM» Buttons «ENDREM»
		«FOREACH svc.viewController.buttons AS b-»
		«FOREACH b.navigations AS n-»
		«IF n.contextScene == this-»
        case "«b.id»":
            «IF n.destinationScene != null-»
			let «n.destinationScene.name.toFirstLower()»VC = «n.destinationScene.name.toFirstUpper()»ParentViewController()
			let nav = UINavigationController()
			nav.viewControllers = [«n.destinationScene.name.toFirstLower()»VC]
			present(nav, animated: true, completion: nil)
			«ELSEIF n.destinationViewController != null-»
			«IF !typeSmartphone.toString().matches("multiVC") || !typeTablet.toString().matches("multiVC")-»
			if layoutType != Constants.SCENE_TYPE_MULTI_VC {
				show«n.destinationViewController.name.toFirstUpper()»VC()
			} else {
				// Do nothing
				break
			}
			«ELSE-»
			// TODO implement the action
			break
			«ENDIF-»
			«ELSE-»
			// TODO implement the action
			break
			«ENDIF-»
        «ENDIF-»
        «ENDFOREACH-»
        «ENDFOREACH-»
        «REM» ListViews «ENDREM»
		«FOREACH svc.viewController.listViews AS lv-»
		«FOREACH lv.navigations AS n-»
		«IF n.contextScene == this-»
		case "«lv.id»":
	    	«IF n.destinationScene != null-»
			let «n.destinationScene.name.toFirstLower()»VC = «n.destinationScene.name.toFirstUpper()»ParentViewController()
			let nav = UINavigationController()
			nav.viewControllers = [«n.destinationScene.name.toFirstLower()»VC]
			present(nav, animated: true, completion: nil)
			«ELSEIF n.destinationViewController != null-»
			«IF !typeSmartphone.toString().matches("multiVC") || !typeTablet.toString().matches("multiVC")-»
			if layoutType != Constants.SCENE_TYPE_MULTI_VC {
				show«n.destinationViewController.name.toFirstUpper()»VC()
			} else {
				// Do nothing
				break
			}
			«ELSE-»
			// TODO implement the action
			break
			«ENDIF-»
			«ELSE-»
			// TODO implement the action
			break
			«ENDIF-»
		«ENDIF-»
		«ENDFOREACH-»
		«ENDFOREACH-»
		«REM» GridViews «ENDREM»
		«FOREACH svc.viewController.gridViews AS gv-»
		«FOREACH gv.navigations AS n-»
		«IF n.contextScene == this-»
		case "«gv.id»":
	    	«IF n.destinationScene != null-»
			let «n.destinationScene.name.toFirstLower()»VC = «n.destinationScene.name.toFirstUpper()»ParentViewController()
			let nav = UINavigationController()
			nav.viewControllers = [«n.destinationScene.name.toFirstLower()»VC]
			present(nav, animated: true, completion: nil)
			«ELSEIF n.destinationViewController != null-»
			«IF !typeSmartphone.toString().matches("multiVC") || !typeTablet.toString().matches("multiVC")-»
			if layoutType != Constants.SCENE_TYPE_MULTI_VC {
				show«n.destinationViewController.name.toFirstUpper()»VC()
			} else {
				// Do nothing
				break
			}
			«ELSE-»
			// TODO implement the action
			break
			«ENDIF-»
			«ELSE-»
			// TODO implement the action
			break
			«ENDIF-»
		«ENDIF-»
		«ENDFOREACH-»
		«ENDFOREACH-»
      	«ENDFOREACH-»
    	default:
    		break
		}
	}
}
«ENDIF-»
«ENDFILE-»
«ENDDEFINE-»

«REM» UI Setup: add child view controllers «ENDREM»
«DEFINE setupUIAddChildViewControllers FOR Scene-»
		«FOREACH sceneViewControllers AS svc-»
		addChildViewController(«svc.viewController.name.toFirstLower()»VC)
		«svc.viewController.name.toFirstLower()»VC.didMove(toParentViewController: self)
		«svc.viewController.name.toFirstLower()»VC.view.translatesAutoresizingMaskIntoConstraints = false
		«ENDFOREACH-»
«ENDDEFINE-»

«REM» UI Setup: add constraints in singleVCTab scenes «ENDREM»
«DEFINE setupUIsingleVCTabConstraints FOR Scene-»
		tabBar = UITabBar(frame: CGRect(x: 0, y: 0, width: 600, height: 48))
        tabBar!.barStyle = UIBarStyle.default
        tabBar!.translatesAutoresizingMaskIntoConstraints = false
        var tabItems = [UITabBarItem]()
        let firstItem = UITabBarItem(title: "«sceneViewControllers.first().viewController.name.toFirstUpper()»", image: nil, tag: 0)
        tabItems.append(firstItem)
        «FOREACH 1.upTo(sceneViewControllers.size - 1) AS i-»
		tabItems.append(UITabBarItem(title: "«sceneViewControllers.get(i).viewController.name.toFirstUpper()»", image: nil, tag: «i»))
		«ENDFOREACH-»
        tabBar!.setItems(tabItems, animated: true)
        tabBar!.selectedItem = firstItem
        tabBar!.delegate = self
        view.addSubview(tabBar!)
        
        NSLayoutConstraint.activate([
            tabBar!.heightAnchor.constraint(equalToConstant: 48),
            tabBar!.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            tabBar!.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            view.bottomAnchor.constraint(equalTo: tabBar!.bottomAnchor)
            ])
«ENDDEFINE-»

«REM» UI Setup: add ViewControllers' views and constraints in multiVC scenes «ENDREM»
«DEFINE setupUImultiVC FOR ViewController-»
		view.backgroundColor = UIColor(colorLiteralRed: 1, green: 1, blue: 1, alpha: 1)
		let mainView = UIView()
		mainView.backgroundColor = UIColor(colorLiteralRed: 1, green: 1, blue: 1, alpha: 1)
		mainView.translatesAutoresizingMaskIntoConstraints = false
		view.addSubview(mainView)
		NSLayoutConstraint.activate([
            mainView.topAnchor.constraint(equalTo: topLayoutGuide.bottomAnchor),
            mainView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            mainView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            mainView.trailingAnchor.constraint(equalTo: view.trailingAnchor)
            ])
		
		«FOREACH containers AS cont-»
		addChildViewController(«cont.childViewController.name.toFirstLower()»VC)
		«cont.childViewController.name.toFirstLower()»VC.didMove(toParentViewController: self)
		let «cont.childViewController.name.toFirstLower()»View = «cont.childViewController.name.toFirstLower()»VC.view!
		«cont.childViewController.name.toFirstLower()»View.translatesAutoresizingMaskIntoConstraints = false
		mainView.addSubview(«cont.childViewController.name.toFirstLower()»View)
		
		«ENDFOREACH-»
		«FOREACH containers AS cont-»
		// «cont.childViewController.name.toFirstLower()»View Constraints
		NSLayoutConstraint.activate([
			«REM» Position Constraints «ENDREM»
			«FOREACH cont.positionConstraints AS posC-»
			«IF posC.layoutEdge.toString().matches("top")-»
			«cont.childViewController.name.toFirstLower()»View.topAnchor.constraint(
			«EXPAND secondPartPositionConstraint FOR posC-»
			«ELSEIF posC.layoutEdge.toString().matches("bottom")-»
			«cont.childViewController.name.toFirstLower()»View.bottomAnchor.constraint(
			«EXPAND secondPartPositionConstraint FOR posC-»
			«ELSEIF posC.layoutEdge.toString().matches("start")-»
			«cont.childViewController.name.toFirstLower()»View.leadingAnchor.constraint(
			«EXPAND secondPartPositionConstraint FOR posC-»
			«ELSEIF posC.layoutEdge.toString().matches("end")-»
			«cont.childViewController.name.toFirstLower()»View.trailingAnchor.constraint(
			«EXPAND secondPartPositionConstraint FOR posC-»
			«ELSEIF posC.layoutEdge.toString().matches("centerX")-»
			«cont.childViewController.name.toFirstLower()»View.centerXAnchor.constraint(
			«EXPAND secondPartPositionConstraint FOR posC-»
			«ELSEIF posC.layoutEdge.toString().matches("centerY")-»
			«cont.childViewController.name.toFirstLower()»View.centerYAnchor.constraint(
			«EXPAND secondPartPositionConstraint FOR posC-»
			«ENDIF-»
			«ENDFOREACH-»
			«IF positionIsUnbinded(true, cont.positionConstraints.layoutEdge)»
			«cont.childViewController.name.toFirstLower()»View.leadingAnchor.constraint(
				equalTo: mainView.leadingAnchor, constant: «cont.posX»)
			«ENDIF-»
			«IF positionIsUnbinded(false, cont.positionConstraints.layoutEdge)»
			«cont.childViewController.name.toFirstLower()»View.topAnchor.constraint(
				equalTo: mainView.topAnchor, constant: «cont.posY»)
			«ENDIF-»
			«REM» Dimension Constraints «ENDREM»
			«IF cont.dimensionConstraint != null-»
			«IF cont.dimensionConstraint.fixedWidth != null-»
			«cont.childViewController.name.toFirstLower()»View.widthAnchor.constraint(
				equalToConstant: «cont.dimensionConstraint.fixedWidth»),
			«ELSEIF cont.dimensionConstraint.widthPercent != null-»
			«cont.childViewController.name.toFirstLower()»View.widthAnchor.constraint(
				equalTo: mainView.widthAnchor, multiplier: «cont.dimensionConstraint.widthPercent»),
			«REM» (***) If the only constraint is on the ratio (width and height are not binded by fixed values, percent values and position constraints), then we fix the width to its default value and leave the height be calculated from width value and ratio value «ENDREM»
			«ELSEIF dimensionIsUnbinded(true, cont.positionConstraints.layoutEdge) && (cont.dimensionConstraint.fixedRatio == null || (cont.dimensionConstraint.fixedRatio != null && (cont.dimensionConstraint.fixedHeight == null && cont.dimensionConstraint.heightPercent == null && dimensionIsUnbinded(false, cont.positionConstraints.layoutEdge))))-»
			«cont.childViewController.name.toFirstLower()»View.widthAnchor.constraint(
				equalToConstant: «cont.defaultWidth»),
			«ENDIF-»
			«IF cont.dimensionConstraint.fixedHeight != null-»
			«cont.childViewController.name.toFirstLower()»View.heightAnchor.constraint(
				equalToConstant: «cont.dimensionConstraint.fixedHeight»),
			«ELSEIF cont.dimensionConstraint.heightPercent != null-»
			«cont.childViewController.name.toFirstLower()»View.heightAnchor.constraint(
				equalTo: mainView.heightAnchor, multiplier: «cont.dimensionConstraint.heightPercent»),
			«REM» (***) «ENDREM»
			«ELSEIF dimensionIsUnbinded(false, cont.positionConstraints.layoutEdge) && cont.dimensionConstraint.fixedRatio == null-»
			«cont.childViewController.name.toFirstLower()»View.heightAnchor.constraint(
				equalToConstant: «cont.defaultHeight»),
			«ENDIF-»
			«IF cont.dimensionConstraint.fixedRatio != null-»
			«cont.childViewController.name.toFirstLower()»View.widthAnchor.constraint(
				equalTo: «cont.childViewController.name.toFirstLower()»View.heightAnchor, multiplier: «((cont.dimensionConstraint.fixedRatio.split(":").get(0).asInteger()) / (cont.dimensionConstraint.fixedRatio.split(":").get(1).asInteger()))»
			«ENDIF-»
			«ELSE-»
			«cont.childViewController.name.toFirstLower()»View.widthAnchor.constraint(
				equalToConstant: «cont.defaultWidth»),
			«cont.childViewController.name.toFirstLower()»View.heightAnchor.constraint(
				equalToConstant: «cont.defaultHeight»)
			«ENDIF-»
            ])
            
        «ENDFOREACH-»
«ENDDEFINE-»

«REM» UI Setup: second part of a single Position Constraint «ENDREM»
«DEFINE secondPartPositionConstraint FOR PositionConstraint-»
			«IF withParent-»
				«IF referenceLayoutEdge.toString().matches("top")-»
				equalTo: mainView.topAnchor, constant: «(uiPhoneControl.marginTop + uiPhoneControl.paddingTop)»),
				«ELSEIF referenceLayoutEdge.toString().matches("bottom")-»
				equalTo: mainView.bottomAnchor, constant: «(uiPhoneControl.marginBottom + uiPhoneControl.paddingBottom)»),
				«ELSEIF referenceLayoutEdge.toString().matches("start")-»
				equalTo: mainView.leadingAnchor, constant: «(uiPhoneControl.marginStart + uiPhoneControl.paddingStart)»),
				«ELSEIF referenceLayoutEdge.toString().matches("end")-»
				equalTo: mainView.trailingAnchor, constant: «(uiPhoneControl.marginEnd + uiPhoneControl.paddingEnd)»),
				«ELSEIF referenceLayoutEdge.toString().matches("centerX")-»
				equalTo: mainView.centerXAnchor, constant: «((uiPhoneControl.marginStart + uiPhoneControl.paddingStart) - (uiPhoneControl.marginEnd + uiPhoneControl.paddingEnd))»),
				«ELSEIF referenceLayoutEdge.toString().matches("centerY")-»
				equalTo: mainView.centerYAnchor, constant: «((uiPhoneControl.marginTop + uiPhoneControl.paddingTop) - (uiPhoneControl.marginBottom + uiPhoneControl.paddingBottom))»),
				«ENDIF-»
			«ELSE-»
				«IF referenceLayoutEdge.toString().matches("top")-»
				«IF layoutEdge.toString().matches("top")-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.topAnchor, constant: «(uiPhoneControl.marginTop + uiPhoneControl.paddingTop)»),
				«ELSE-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.topAnchor, constant: «(uiPhoneControl.marginBottom + uiPhoneControl.paddingBottom + referenceElement.marginTop)»),
				«ENDIF-»
				«ELSEIF referenceLayoutEdge.toString().matches("bottom")-»
				«IF layoutEdge.toString().matches("bottom")-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.bottomAnchor, constant: «(uiPhoneControl.marginBottom + uiPhoneControl.paddingBottom)»),
				«ELSE-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.bottomAnchor, constant: «(uiPhoneControl.marginTop + uiPhoneControl.paddingTop + referenceElement.marginBottom)»),
				«ENDIF-»
				«ELSEIF referenceLayoutEdge.toString().matches("start")-»
				«IF layoutEdge.toString().matches("start")-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.leadingAnchor, constant: «(uiPhoneControl.marginStart + uiPhoneControl.paddingStart)»),
				«ELSE-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.leadingAnchor, constant: «(uiPhoneControl.marginEnd + uiPhoneControl.paddingEnd + referenceElement.marginStart)»),
				«ENDIF-»
				«ELSEIF referenceLayoutEdge.toString().matches("end")-»
				«IF layoutEdge.toString().matches("end")-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.trailingAnchor, constant: «(uiPhoneControl.marginEnd + uiPhoneControl.paddingEnd)»),
				«ELSE-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.trailingAnchor, constant: «(uiPhoneControl.marginStart + uiPhoneControl.paddingStart + referenceElement.marginEnd)»),
				«ENDIF-»
				«ELSEIF referenceLayoutEdge.toString().matches("centerX")-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.centerXAnchor, constant: «((uiPhoneControl.marginStart + uiPhoneControl.paddingStart) - (uiPhoneControl.marginEnd + uiPhoneControl.paddingEnd))»),
				«ELSEIF referenceLayoutEdge.toString().matches("centerY")-»
				equalTo: «((Container) referenceElement).childViewController.name.toFirstLower()»View.centerYAnchor, constant: «((uiPhoneControl.marginTop + uiPhoneControl.paddingTop) - (uiPhoneControl.marginBottom + uiPhoneControl.paddingBottom))»),
				«ENDIF-»
			«ENDIF-»
«ENDDEFINE-»

«REM» Model's ViewControllers are translated into ViewControllers in folder ChildViewControllers «ENDREM»
«DEFINE viewController FOR ViewController-»
«FILE application.name +"/"+application.name +"/ChildViewControllers/"+ name.toFirstUpper()+"ViewController.swift"-»
//
//  «name.toFirstUpper()»ViewController.swift
//  «name.toFirstUpper()»
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «application.companyIdentifier.split(".").last()». All rights reserved.
//
«EXPAND ios_viewcontrollers_templates::Imports::publicImports-»

class «name.toFirstUpper()»ViewController: «EXPAND ios_viewcontrollers_templates::Protocols::publicProtocols» {

	«EXPAND ios_viewcontrollers_templates::PropertiesDeclarations::propertiesDeclarations»
	
	override func viewDidLoad() {
	    super.viewDidLoad()
		«EXPAND ios_viewcontrollers_templates::ViewDidLoad::viewDidLoad-»
	}
	
	override func viewDidAppear(_ animated: Bool) {
	    super.viewDidAppear(animated)
	    «EXPAND ios_viewcontrollers_templates::ViewDidAppear::viewDidAppear-»
	}
	
	override func viewDidDisappear(_ animated: Bool) {
		super.viewDidDisappear(animated)
		«EXPAND ios_viewcontrollers_templates::ViewDidDisappear::viewDidDisappear-»
	}
	«EXPAND ios_viewcontrollers_templates::Audio::audio-»
	«EXPAND ios_viewcontrollers_templates::Buttons::buttons-»
	«EXPAND ios_viewcontrollers_templates::Camera::camera-»
	«EXPAND ios_viewcontrollers_templates::Cards::cards-»
	«EXPAND ios_viewcontrollers_templates::Datepickers::datepickers-»
	«EXPAND ios_viewcontrollers_templates::GridViews::gridViews-»
	«EXPAND ios_viewcontrollers_templates::ListViews::listViews-»
	«EXPAND ios_viewcontrollers_templates::Sliders::sliders-»
	«EXPAND ios_viewcontrollers_templates::Spinners::spinners-»
	«EXPAND ios_viewcontrollers_templates::Switches::switches-»
	«EXPAND ios_viewcontrollers_templates::Timepickers::timepickers-»
	
	override func viewWillAppear(_ animated: Bool) {
		super.viewWillAppear(animated)
	}
	
	override func viewWillDisappear(_ animated: Bool) {
		super.viewWillDisappear(animated)
	}
	
	override func didReceiveMemoryWarning() {
	    super.didReceiveMemoryWarning()
	    // Dispose of any resources that can be recreated.
	}
}
«ENDFILE-»
«ENDDEFINE-»

«REM» Menu Files «ENDREM»
«DEFINE menuViewController FOR Application-»
«FILE name +"/"+name +"/Menu/MenuViewController.swift"-»
//
//  MenuViewController.swift
//  MenuViewController
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «companyIdentifier.split(".").last()-». All rights reserved.
//

import UIKit

protocol MenuViewControllerDelegate: class {
	func menuViewController(controller: MenuViewController, didSelectItem selectedItem: MenuItem)
}

final class MenuViewController: UITableViewController {

	// MARK: - Properties
	weak var delegate: MenuViewControllerDelegate?
	var menuItems: [MenuItem] = []
	
	// MARK: Initialization
    init() {
        «FOREACH 0.upTo(menu.menuItems.size - 1) AS i-»
    	let mi«(i+1)» = MenuItem(title: "«menu.menuItems.get(i).title»", destinationID: "«menu.menuItems.get(i).navigation.destinationScene.name.toFirstUpper()»")
		menuItems.append(mi«(i+1)»)
		«ENDFOREACH-»
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder aDecoder: NSCoder) {
    	«FOREACH 0.upTo(menu.menuItems.size - 1) AS i-»
    	let mi«(i+1)» = MenuItem(title: "«menu.menuItems.get(i).title»", destinationID: "«menu.menuItems.get(i).navigation.destinationScene.name.toFirstUpper()»")
		menuItems.append(mi«(i+1)»)
		«ENDFOREACH-»
        super.init(coder: aDecoder)
    }
}

// MARK: - UITableViewDataSource
extension MenuViewController {

	override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		return menuItems.count
	}
  
	override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		let cell = tableView.dequeueReusableCell(withIdentifier: "MenuCell", for: indexPath) as! MenuViewCell

		let item = menuItems[indexPath.row]
		cell.destinationLabel.text = item.title

		return cell
	}
}

// MARK: - UITableViewDelegate
extension MenuViewController {

	override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		tableView.deselectRow(at: indexPath, animated: true)
		let selectedItem = menuItems[indexPath.row]
		delegate?.menuViewController(controller: self, didSelectItem: selectedItem)
	}
}
«ENDFILE-»

«FILE name +"/"+name +"/Menu/MenuPresentationManager.swift"-»
//
//  MenuPresentationManager.swift
//  MenuPresentationManager
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «companyIdentifier.split(".").last()-». All rights reserved.
//

import UIKit

final class MenuPresentationManager: NSObject {

}

// MARK: - UIViewControllerTransitioningDelegate
extension MenuPresentationManager: UIViewControllerTransitioningDelegate {

	func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -> UIPresentationController? {
		let presentationController = MenuPresentationController(presentedViewController: presented, presenting: presenting)
		return presentationController
  }

	func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -> UIViewControllerAnimatedTransitioning? {
		return MenuPresentationAnimator(isPresentation: true)
	}

	func animationController(forDismissed dismissed: UIViewController) -> UIViewControllerAnimatedTransitioning? {
		return MenuPresentationAnimator(isPresentation: false)
	}
}
«ENDFILE-»

«FILE name +"/"+name +"/Menu/MenuPresentationController.swift"-»
//
//  MenuPresentationController.swift
//  MenuPresentationController
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «companyIdentifier.split(".").last()-». All rights reserved.
//

import UIKit

final class MenuPresentationController: UIPresentationController {
  
	// MARK: - Properties
	fileprivate var dimmingView: UIView!
  
	override var frameOfPresentedViewInContainerView: CGRect {
		var frame: CGRect = .zero
		frame.size = size(forChildContentContainer: presentedViewController, withParentContainerSize: containerView!.bounds.size)
		frame.origin = .zero
		return frame
	}
  
	// MARK: - Initializers
	override init(presentedViewController: UIViewController, presenting presentingViewController: UIViewController?) {
		super.init(presentedViewController: presentedViewController, presenting: presentingViewController)
		setupDimmingView()
	}
  
	override func presentationTransitionWillBegin() {
		containerView?.insertSubview(dimmingView, at: 0)
		NSLayoutConstraint.activate(NSLayoutConstraint.constraints(withVisualFormat: "V:|[dimmingView]|", options: [], metrics: nil, views: ["dimmingView": dimmingView]))
		NSLayoutConstraint.activate(NSLayoutConstraint.constraints(withVisualFormat: "H:|[dimmingView]|", options: [], metrics: nil, views: ["dimmingView": dimmingView]))
    
		guard let coordinator = presentedViewController.transitionCoordinator else {
			dimmingView.alpha = 1.0
			return
		}
    
		coordinator.animate(alongsideTransition: { _ in
			self.dimmingView.alpha = 1.0
		})
	}
  
	override func dismissalTransitionWillBegin() {
		guard let coordinator = presentedViewController.transitionCoordinator else {
			dimmingView.alpha = 0.0
			return
		}
    
		coordinator.animate(alongsideTransition: { _ in
			self.dimmingView.alpha = 0.0
		})
	}
  
	override func containerViewWillLayoutSubviews() {
		presentedView?.frame = frameOfPresentedViewInContainerView
	}
  
	override func size(forChildContentContainer container: UIContentContainer, withParentContainerSize parentSize: CGSize) -> CGSize {
		return CGSize(width: parentSize.width*(2.0/3.0), height: parentSize.height)
	}
}

// MARK: - Private
private extension MenuPresentationController {
  
	func setupDimmingView() {
		dimmingView = UIView()
		dimmingView.translatesAutoresizingMaskIntoConstraints = false
		dimmingView.backgroundColor = UIColor(white: 0.0, alpha: 0.5)
		dimmingView.alpha = 0.0
    
		let recognizer = UITapGestureRecognizer(target: self, action: #selector(handleTap(recognizer:)))
		dimmingView.addGestureRecognizer(recognizer)
	}
  
	dynamic func handleTap(recognizer: UITapGestureRecognizer) {
		presentingViewController.dismiss(animated: true)
	}
}
«ENDFILE-»

«FILE name +"/"+name +"/Menu/MenuPresentationAnimator.swift"-»
//
//  MenuPresentationAnimator.swift
//  MenuPresentationAnimator
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «companyIdentifier.split(".").last()-». All rights reserved.
//

import UIKit

final class MenuPresentationAnimator: NSObject {

	// MARK: - Properties
	let isPresentation: Bool

	// MARK: - Initializers
	init(isPresentation: Bool) {
		self.isPresentation = isPresentation
		super.init()
	}
}

// MARK: - UIViewControllerAnimatedTransitioning
extension MenuPresentationAnimator: UIViewControllerAnimatedTransitioning {
  
	func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -> TimeInterval {
		return 0.2
	}
  
	func animateTransition(using transitionContext: UIViewControllerContextTransitioning) {
		let key = isPresentation ? UITransitionContextViewControllerKey.to : UITransitionContextViewControllerKey.from
		let controller = transitionContext.viewController(forKey: key)!
    
		if isPresentation {
			transitionContext.containerView.addSubview(controller.view)
		}

		let presentedFrame = transitionContext.finalFrame(for: controller)
		var dismissedFrame = presentedFrame
		dismissedFrame.origin.x = -presentedFrame.width

		let initialFrame = isPresentation ? dismissedFrame : presentedFrame
		let finalFrame = isPresentation ? presentedFrame : dismissedFrame

		let animationDuration = transitionDuration(using: transitionContext)
		controller.view.frame = initialFrame
		UIView.animate(withDuration: animationDuration, animations: {
			controller.view.frame = finalFrame
		}) { finished in
			transitionContext.completeTransition(finished)
		}
	}
}
«ENDFILE-»

«FILE name +"/"+name +"/Menu/MenuViewCell.swift"-»
//
//  MenuViewCell.swift
//  MenuViewCell
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «companyIdentifier.split(".").last()-». All rights reserved.
//

import UIKit

final class MenuViewCell: UITableViewCell {
  
	// MARK: - IBOutlets
	@IBOutlet weak var destinationLabel: UILabel!
}
«ENDFILE-»

«FILE name +"/"+name +"/Menu/MenuItem.swift"-»
//
//  MenuItem.swift
//  MenuItem
//
//  Automatically generated by MobileCodeGenerator 4.
//  Copyright 2018 «companyIdentifier.split(".").last()-». All rights reserved.
//

import Foundation

struct MenuItem {
	// MARK: - Properties
	let title: String
	let destinationID: String
  
	// MARK: - Initializers
	init(title: String, destinationID: String) {
		self.title = title
		self.destinationID = destinationID
	}
}
«ENDFILE-»
«ENDDEFINE-»